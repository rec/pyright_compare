{
    "commits": {
        "before": {
            "committer_date": "2025-05-19 22:57:29",
            "commit_id": "701e22112dd",
            "message": "[PT2][Optimus][Observability] Refactor the logging to avoid excessive tlparse log (#153584)"
        },
        "after": {
            "committer_date": "2025-05-19 23:32:36",
            "commit_id": "d81217be2e4",
            "message": "Revert \"Improve torch.ops typing (#153558)\""
        }
    },
    "completeness": [0.368147, 0.367961],
    "filename": "pyright_compare.082960.701e22112dd-d81217be2e4.json",
    "diff": {
        "absolute": {
            "exportedSymbolCounts": {
                "withKnownType": -3,
                "withAmbiguousType": -5,
                "withUnknownType": 8
            },
            "otherSymbolCounts": {
                "withKnownType": -8,
                "withAmbiguousType": -4,
                "withUnknownType": -7
            },
            "missingFunctionDocStringCount": -7,
            "missingClassDocStringCount": -1,
            "completenessScore": -0.00018605805011162602
        },
        "percent": {
            "exportedSymbolCounts": {
                "withKnownType": -0.05053908355795148,
                "withAmbiguousType": -0.6045949214026602,
                "withUnknownType": 0.08546095502617242
            },
            "otherSymbolCounts": {
                "withKnownType": -0.4149377593360996,
                "withAmbiguousType": -5.47945205479452,
                "withUnknownType": -0.41055718475073316
            },
            "missingFunctionDocStringCount": -0.1967950520101209,
            "missingClassDocStringCount": -0.0968054211035818,
            "completenessScore": -0.05053908355794909
        },
        "symbols": {
            "added": [
                "torch._ops._PyOpNamespace",
                "torch._ops._PyOpNamespace.__getattr__",
                "torch._ops._PyOpNamespace.__init__"
            ],
            "common": {
                "torch._ops.OpOverload.__init__": {
                    "diagnostics": {
                        "added": [
                            "Type annotation for parameter \"op\" is missing",
                            "Type annotation for parameter \"op_dk\" is missing",
                            "Type annotation for parameter \"overloadpacket\" is missing",
                            "Type annotation for parameter \"schema\" is missing",
                            "Type annotation for parameter \"tags\" is missing"
                        ]
                    }
                },
                "torch._ops.OpOverload.redispatch": {
                    "diagnostics": {
                        "added": [
                            "Return type annotation is missing",
                            "Type annotation for parameter \"keyset\" is missing"
                        ]
                    }
                },
                "torch._ops.OpOverloadPacket.__getattr__": {
                    "diagnostics": {
                        "added": [
                            "Type annotation for parameter \"key\" is missing"
                        ],
                        "removed": [
                            "Return type is partially unknown\n\u00a0\u00a0Return type is \"OpOverload\""
                        ]
                    }
                },
                "torch._ops.OpOverloadPacket.__init__": {
                    "diagnostics": {
                        "added": [
                            "Type annotation for parameter \"op\" is missing",
                            "Type annotation for parameter \"op_name\" is missing",
                            "Type annotation for parameter \"overload_names\" is missing",
                            "Type annotation for parameter \"qualified_op_name\" is missing"
                        ]
                    }
                },
                "torch._ops._OpNamespace.__getattr__": {
                    "diagnostics": {
                        "added": [
                            "Type annotation for parameter \"op_name\" is missing"
                        ],
                        "removed": [
                            "Return type is partially unknown\n\u00a0\u00a0Return type is \"OpOverloadPacket\""
                        ]
                    }
                },
                "torch._ops._OpNamespace.__init__": {
                    "diagnostics": {
                        "added": [
                            "Type annotation for parameter \"name\" is missing"
                        ]
                    }
                },
                "torch._ops._Ops.__getattr__": {
                    "diagnostics": {
                        "added": [
                            "Return type annotation is missing"
                        ],
                        "removed": [
                            "Return type is partially unknown\n\u00a0\u00a0Return type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch._subclasses.fake_tensor.FakeTensorMode.lift_fns": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"dict\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"dict[Unknown | Any, Literal[True]]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"dict[OpOverload, Literal[True]]\""
                        ]
                    }
                },
                "torch.ao.ns.fx.graph_matcher.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.ao.ns.fx.mappings.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.ao.ns.fx.pattern_utils.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.ao.ns.fx.utils.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.ao.ns.fx.weight_utils.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.ao.quantization.quantizer.x86_inductor_quantizer.default_quantizable_ops": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | Any]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | OpOverload]\""
                        ]
                    }
                },
                "torch.ao.quantization.quantizer.x86_inductor_quantizer.quantizable_ops": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | Any]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | OpOverload]\""
                        ]
                    }
                },
                "torch.autograd.profiler.record_function.record": {
                    "diagnostics": {
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"Any\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.comm_mode_features_example.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.comm_mode_features_example.c10d_functional": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.comm_mode_features_example.supported_ops": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"list\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"list[Unknown | Any]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"list[OpOverload]\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.torchrec_sharding_example.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.torchrec_sharding_example.supported_ops": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"list\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"list[Unknown | Any]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"list[OpOverload]\""
                        ]
                    }
                },
                "torch.distributed.tensor.parallel.loss.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.distributed.tensor.parallel.loss.customized_loss_ops": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"dict\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"dict[Unknown | Any, (op_call: OpOverload, args: tuple[object, ...], kwargs: dict[str, object]) -> object]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"dict[OpOverload, (op_call: OpOverload, args: tuple[object, ...], kwargs: dict[str, object]) -> object]\""
                        ]
                    }
                },
                "torch.export.decomp_utils.PRESERVED_ATEN_CIA_OPS": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"set\" has partially unknown type\n\u00a0\u00a0Type is [object Object]"
                        ]
                    }
                },
                "torch.fx.experimental.proxy_tensor.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.fx.experimental.proxy_tensor.prim": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.fx.experimental.symbolic_shapes.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.fx.passes.dialect.common.cse_pass.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                },
                "torch.fx.passes.dialect.common.cse_pass.inplace_ops": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"set\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | Any]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[OpOverloadPacket]\""
                        ]
                    }
                },
                "torch.fx.passes.dialect.common.cse_pass.rand_ops": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"set\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | Any]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[OpOverloadPacket]\""
                        ]
                    }
                },
                "torch.masked.maskedtensor.passthrough.PASSTHROUGH_FNS": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"list\" has partially unknown type\n\u00a0\u00a0Type is [object Object]"
                        ]
                    }
                },
                "torch.quantized_gru": {
                    "diagnostics": {
                        "added": [
                            "Type unknown for type alias \"torch.quantized_gru\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"OpOverloadPacket\""
                        ]
                    }
                },
                "torch.quantized_lstm": {
                    "diagnostics": {
                        "added": [
                            "Type unknown for type alias \"torch.quantized_lstm\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"OpOverloadPacket\""
                        ]
                    }
                },
                "torch.utils.checkpoint.SAC_IGNORED_OPS": {
                    "diagnostics": {
                        "added": [
                            "Type argument 1 for class \"set\" has partially unknown type\n\u00a0\u00a0Type is [object Object]"
                        ]
                    }
                },
                "torch.utils.flop_counter.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ]
                    }
                }
            },
            "removed": [
                "torch._ops.HigherOrderOperator",
                "torch._ops.HigherOrderOperator.__call__",
                "torch._ops.HigherOrderOperator.__init__",
                "torch._ops.HigherOrderOperator.__name__",
                "torch._ops.HigherOrderOperator.__str__",
                "torch._ops.HigherOrderOperator.cacheable",
                "torch._ops.HigherOrderOperator.dispatch",
                "torch._ops.HigherOrderOperator.fallthrough",
                "torch._ops.HigherOrderOperator.gen_schema",
                "torch._ops.HigherOrderOperator.name",
                "torch._ops.HigherOrderOperator.namespace",
                "torch._ops.HigherOrderOperator.non_fallthrough_keys",
                "torch._ops.HigherOrderOperator.py_autograd_impl",
                "torch._ops.HigherOrderOperator.py_impl",
                "torch._ops.OpOverloadPacket.__file__",
                "torch._ops._HigherOrderNamespace",
                "torch._ops._HigherOrderNamespace.__file__",
                "torch._ops._HigherOrderNamespace.__getattr__",
                "torch._ops._HigherOrderNamespace.__init__",
                "torch._ops._HigherOrderNamespace.__iter__",
                "torch._ops._OpNamespace.__file__",
                "torch._ops._Ops.higher_order"
            ]
        }
    }
}
