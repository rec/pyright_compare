{
    "commits": {
        "before": {
            "committer_date": "2025-05-19 14:13:19",
            "commit_id": "3cd5b3b1e75",
            "message": "[AOTI] Skip a rocm test (#153828)"
        },
        "after": {
            "committer_date": "2025-05-19 14:52:32",
            "commit_id": "c5cba39d469",
            "message": "Improve torch.ops typing (#153558)"
        }
    },
    "completeness": [0.367899, 0.368085],
    "filename": "full-run/pyright_compare.082931.3cd5b3b1e75-c5cba39d469.json",
    "diff": {
        "absolute": {
            "exportedSymbolCounts": {
                "withKnownType": 3,
                "withAmbiguousType": 5,
                "withUnknownType": -8
            },
            "otherSymbolCounts": {
                "withKnownType": 8,
                "withAmbiguousType": 4,
                "withUnknownType": 7
            },
            "missingFunctionDocStringCount": 7,
            "missingClassDocStringCount": 1,
            "completenessScore": 0.00018605805011162602
        },
        "percent": {
            "exportedSymbolCounts": {
                "withKnownType": 0.05057316250842886,
                "withAmbiguousType": 0.6082725060827251,
                "withUnknownType": -0.08537886872998933
            },
            "otherSymbolCounts": {
                "withKnownType": 0.4166666666666667,
                "withAmbiguousType": 5.797101449275362,
                "withUnknownType": 0.4122497055359246
            },
            "missingFunctionDocStringCount": 0.19718309859154928,
            "missingClassDocStringCount": 0.09689922480620156,
            "completenessScore": 0.050573162508426465
        },
        "symbols": {
            "added": [
                "torch._ops.HigherOrderOperator",
                "torch._ops.HigherOrderOperator.__call__",
                "torch._ops.HigherOrderOperator.__init__",
                "torch._ops.HigherOrderOperator.__name__",
                "torch._ops.HigherOrderOperator.__str__",
                "torch._ops.HigherOrderOperator.cacheable",
                "torch._ops.HigherOrderOperator.dispatch",
                "torch._ops.HigherOrderOperator.fallthrough",
                "torch._ops.HigherOrderOperator.gen_schema",
                "torch._ops.HigherOrderOperator.name",
                "torch._ops.HigherOrderOperator.namespace",
                "torch._ops.HigherOrderOperator.non_fallthrough_keys",
                "torch._ops.HigherOrderOperator.py_autograd_impl",
                "torch._ops.HigherOrderOperator.py_impl",
                "torch._ops.OpOverloadPacket.__file__",
                "torch._ops._HigherOrderNamespace",
                "torch._ops._HigherOrderNamespace.__file__",
                "torch._ops._HigherOrderNamespace.__getattr__",
                "torch._ops._HigherOrderNamespace.__init__",
                "torch._ops._HigherOrderNamespace.__iter__",
                "torch._ops._OpNamespace.__file__",
                "torch._ops._Ops.higher_order"
            ],
            "common": {
                "torch._ops.OpOverload.__init__": {
                    "isTypeKnown": true,
                    "diagnostics": {
                        "removed": [
                            "Type annotation for parameter \"op\" is missing",
                            "Type annotation for parameter \"op_dk\" is missing",
                            "Type annotation for parameter \"overloadpacket\" is missing",
                            "Type annotation for parameter \"schema\" is missing",
                            "Type annotation for parameter \"tags\" is missing"
                        ]
                    }
                },
                "torch._ops.OpOverload.redispatch": {
                    "diagnostics": {
                        "removed": [
                            "Return type annotation is missing",
                            "Type annotation for parameter \"keyset\" is missing"
                        ]
                    }
                },
                "torch._ops.OpOverloadPacket.__getattr__": {
                    "diagnostics": {
                        "added": [
                            "Return type is partially unknown\n\u00a0\u00a0Return type is \"OpOverload\""
                        ],
                        "removed": [
                            "Type annotation for parameter \"key\" is missing"
                        ]
                    }
                },
                "torch._ops.OpOverloadPacket.__init__": {
                    "isTypeKnown": true,
                    "diagnostics": {
                        "removed": [
                            "Type annotation for parameter \"op\" is missing",
                            "Type annotation for parameter \"op_name\" is missing",
                            "Type annotation for parameter \"overload_names\" is missing",
                            "Type annotation for parameter \"qualified_op_name\" is missing"
                        ]
                    }
                },
                "torch._ops._OpNamespace.__getattr__": {
                    "diagnostics": {
                        "added": [
                            "Return type is partially unknown\n\u00a0\u00a0Return type is \"OpOverloadPacket\""
                        ],
                        "removed": [
                            "Type annotation for parameter \"op_name\" is missing"
                        ]
                    }
                },
                "torch._ops._OpNamespace.__init__": {
                    "isTypeKnown": true,
                    "diagnostics": {
                        "removed": [
                            "Type annotation for parameter \"name\" is missing"
                        ]
                    }
                },
                "torch._ops._Ops.__getattr__": {
                    "diagnostics": {
                        "added": [
                            "Return type is partially unknown\n\u00a0\u00a0Return type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Return type annotation is missing"
                        ]
                    }
                },
                "torch._subclasses.fake_tensor.FakeTensorMode.lift_fns": {
                    "isTypeAmbiguous": true,
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"dict[OpOverload, Literal[True]]\""
                        ],
                        "removed": [
                            "Type argument 1 for class \"dict\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"dict[Unknown | Any, Literal[True]]\""
                        ]
                    }
                },
                "torch.ao.ns.fx.graph_matcher.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.ao.ns.fx.mappings.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.ao.ns.fx.pattern_utils.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.ao.ns.fx.utils.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.ao.ns.fx.weight_utils.toq": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.ao.quantization.quantizer.x86_inductor_quantizer.default_quantizable_ops": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | OpOverload]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | Any]\""
                        ]
                    }
                },
                "torch.ao.quantization.quantizer.x86_inductor_quantizer.quantizable_ops": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | OpOverload]\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | Any]\""
                        ]
                    }
                },
                "torch.autograd.profiler.record_function.record": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"Any\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.comm_mode_features_example.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.comm_mode_features_example.c10d_functional": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.comm_mode_features_example.supported_ops": {
                    "isTypeAmbiguous": true,
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"list[OpOverload]\""
                        ],
                        "removed": [
                            "Type argument 1 for class \"list\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"list[Unknown | Any]\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.torchrec_sharding_example.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.distributed.tensor.examples.torchrec_sharding_example.supported_ops": {
                    "isTypeAmbiguous": true,
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"list[OpOverload]\""
                        ],
                        "removed": [
                            "Type argument 1 for class \"list\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"list[Unknown | Any]\""
                        ]
                    }
                },
                "torch.distributed.tensor.parallel.loss.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.distributed.tensor.parallel.loss.customized_loss_ops": {
                    "isTypeAmbiguous": true,
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"dict[OpOverload, (op_call: OpOverload, args: tuple[object, ...], kwargs: dict[str, object]) -> object]\""
                        ],
                        "removed": [
                            "Type argument 1 for class \"dict\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"dict[Unknown | Any, (op_call: OpOverload, args: tuple[object, ...], kwargs: dict[str, object]) -> object]\""
                        ]
                    }
                },
                "torch.export.decomp_utils.PRESERVED_ATEN_CIA_OPS": {
                    "isTypeKnown": true,
                    "diagnostics": {
                        "removed": [
                            "Type argument 1 for class \"set\" has partially unknown type\n\u00a0\u00a0Type is [object Object]"
                        ]
                    }
                },
                "torch.fx.experimental.proxy_tensor.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.fx.experimental.proxy_tensor.prim": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.fx.experimental.symbolic_shapes.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.fx.passes.dialect.common.cse_pass.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                },
                "torch.fx.passes.dialect.common.cse_pass.inplace_ops": {
                    "isTypeAmbiguous": true,
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[OpOverloadPacket]\""
                        ],
                        "removed": [
                            "Type argument 1 for class \"set\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | Any]\""
                        ]
                    }
                },
                "torch.fx.passes.dialect.common.cse_pass.rand_ops": {
                    "isTypeAmbiguous": true,
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[OpOverloadPacket]\""
                        ],
                        "removed": [
                            "Type argument 1 for class \"set\" has partially unknown type\n\u00a0\u00a0Type is [object Object]",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"set[Unknown | Any]\""
                        ]
                    }
                },
                "torch.masked.maskedtensor.passthrough.PASSTHROUGH_FNS": {
                    "isTypeKnown": true,
                    "diagnostics": {
                        "removed": [
                            "Type argument 1 for class \"list\" has partially unknown type\n\u00a0\u00a0Type is [object Object]"
                        ]
                    }
                },
                "torch.quantized_gru": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"OpOverloadPacket\""
                        ],
                        "removed": [
                            "Type unknown for type alias \"torch.quantized_gru\""
                        ]
                    }
                },
                "torch.quantized_lstm": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"OpOverloadPacket\""
                        ],
                        "removed": [
                            "Type unknown for type alias \"torch.quantized_lstm\""
                        ]
                    }
                },
                "torch.utils.checkpoint.SAC_IGNORED_OPS": {
                    "isTypeKnown": true,
                    "diagnostics": {
                        "removed": [
                            "Type argument 1 for class \"set\" has partially unknown type\n\u00a0\u00a0Type is [object Object]"
                        ]
                    }
                },
                "torch.utils.flop_counter.aten": {
                    "diagnostics": {
                        "added": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_OpNamespace\""
                        ],
                        "removed": [
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace | _OpNamespace\"",
                            "Type is missing type annotation and could be inferred differently by type checkers\n\u00a0\u00a0Inferred type is \"_PyOpNamespace\""
                        ]
                    }
                }
            },
            "removed": [
                "torch._ops._PyOpNamespace",
                "torch._ops._PyOpNamespace.__getattr__",
                "torch._ops._PyOpNamespace.__init__"
            ]
        }
    }
}
